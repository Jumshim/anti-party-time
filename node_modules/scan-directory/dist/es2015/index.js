'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forExt = exports.rejectNodeModules = undefined;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const _promisify = (fn, context) => (...args) => new Promise((resolve, reject) => {
  fn.call(context, ...args, (error, ok) => {
    if (error) reject(error);
    resolve(ok);
  });
});

const readdir = _promisify(_fs2.default.readdir, _fs2.default);
const stats = _promisify(_fs2.default.stat, _fs2.default);

const rejectNodeModules = exports.rejectNodeModules = (file, stats) => stats.isDirectory() && file.match(/node_modules/);

const acceptAll = () => true;

const forExt = exports.forExt = ext => {
  const reg = new RegExp('\.' + ext + '$', 'i');

  return file => {
    const match = file.match(reg);
    return !!match && match[0][0] === '.';
  };
};

exports.default = async function (root, accept = acceptAll, reject = rejectNodeModules) {
  if (!_fs2.default.existsSync(root)) {
    return [];
  }

  const files = [];

  async function walk(dir) {

    const list = await readdir(dir);
    const blockers = list.map(async file => {
      const fullpath = _path2.default.resolve(dir, file);
      try {
        // file could be a symlink
        const stat = await stats(fullpath);

        if (reject(fullpath, stat)) {
          return;
        }

        if (stat.isDirectory()) {
          return walk(fullpath);
        }

        if (accept(fullpath, stat)) {
          files.push(fullpath);
        }
      } catch (e) {
        // do nothing
        // console.error('could not handle', fullpath, e);
      }
    });
    return Promise.all(blockers);
  }

  await walk(root);
  return files;
};